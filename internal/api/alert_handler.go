package api

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time" // Import time package for time.Now()
    "github.com/Kelvinkhyd/GuardianAI/internal/models" // Adjust this path!
)

// HandleAlerts receives incoming security alerts via HTTP POST.
func HandleAlerts(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Only POST requests are accepted", http.StatusMethodNotAllowed)
        return
    }

    var alert models.SecurityAlert
    err := json.NewDecoder(r.Body).Decode(&alert)
    if err != nil {
        http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
        return
    }

    // --- Basic Alert Processing (for now) ---
    // In a real scenario, you'd:
    // 1. Validate the alert data more rigorously.
    // 2. Assign a unique ID if not provided by the source.
    // 3. Store the alert in a database (PostgreSQL/Elasticsearch).
    // 4. Send the alert to a message queue (Kafka) for further processing by the AI/orchestration engine.
    // 5. Respond to the client.

    // For now, let's just log the incoming alert and assign a simple status.
    // In a real system, the ID would likely be generated by your system or come from the SIEM.
    // For this MVP, let's ensure it has an ID, even if simple.
    if alert.ID == "" {
        alert.ID = fmt.Sprintf("alert-%d", time.Now().UnixNano()) // Simple ID generation
    }
    alert.Status = "new" // Initial status

    log.Printf("Received new alert: ID=%s, Source=%s, Category=%s, Severity=%s, Hostname=%s",
        alert.ID, alert.Source, alert.Category, alert.Severity, alert.Hostname)

    // Respond to the client
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusAccepted) // 202 Accepted
    json.NewEncoder(w).Encode(map[string]string{"message": "Alert received and is being processed", "alert_id": alert.ID})
}